### 事件代理

事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素，当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数

事件流的都会经过三个阶段： **捕获阶段 -> 目标阶段 -> 冒泡阶段**，而事件委托就是在**冒泡阶段**完成

#### 场景一：列表大数据

如下列表中含有大量数据，需要在点击列表项时响应一个事件，如果给每一项都绑定一个函数，对**内存的消耗是非常大**的

```html
<ul id="list">
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
   ......
  <li>item n</li>
</ul>
```

使用事件委托把点击事件绑定在父元素`ul`上面,再去匹配目标元素

```js
// 给父层元素绑定事件
document.getElementById('list').addEventListener('click', function (e) {
    // 兼容性处理
    var event = e || window.event;
    var target = event.target || event.srcElement;
    // 判断是否匹配目标元素
    if (target.nodeName.toLocaleLowerCase() === 'li') {
        console.log('the content is: ', target.innerHTML);
    }
});
```

#### 场景二：元素的动态删减

点击`input`可以动态添加元素

```html
<input type="button" name="" id="btn" value="添加" />
<ul id="ul1">
    <li>item 1</li>
    <li>item 2</li>
    <li>item 3</li>
    <li>item 4</li>
</ul>
```

使用事件委托

```js
const oBtn = document.getElementById("btn");
const oUl = document.getElementById("ul1");
const num = 4;

//事件委托，添加的子元素也有事件
oUl.onclick = function (ev) {
    ev = ev || window.event;
    const target = ev.target || ev.srcElement;
    if (target.nodeName.toLowerCase() == 'li') {
        console.log('the content is: ', target.innerHTML);
    }

};

//添加新节点
oBtn.onclick = function () {
    num++;
    const oLi = document.createElement('li');
    oLi.innerHTML = `item ${num}`;
    oUl.appendChild(oLi);
};
```

#### 总结：

- 减少了内存的消耗
- 在动态绑定事件的情况下是可以减少很多重复工作的
- 适合事件委托的事件有：`click`，`mousedown`，`mouseup`，`keydown`，`keyup`，`keypress`

局限性：

- `focus`、`blur `这些事件没有事件冒泡机制，所以无法进行委托绑定事件
- `mousemove`、`mouseout `这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的

- 如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件
# 编译构建

## 编译构建是什么？

构建，或者叫作编译，是前端工程化体系中功能最繁琐、最复杂的模块，承担着从源代码转化为宿主浏览器可执行的代码，其核心是资源的管理。前端的产出资源包括JS、CSS、HTML等，分别对应的源代码则是：

- 领先于浏览器实现的ECMAScript规范编写的JS代码（ES6/7/8...）。
- Less/Sass预编译语法编写的CSS代码。
- Jade/EJS/Mustache等模板语法编写的HTML代码。

以上源代码是无法在浏览器环境下运行的，构建工作的核心便是将其转化为宿主可执行代码，分别对应：

- ECMAScript规范的转译。
- CSS预编译语法转译。
- HTML模板渲染。

如今3大主流构建工具：Webpack、Rollup、Vite。


## Webpack

### Webpack原理

`Webpack` 编译项目的工作机制是，递归找出所有依赖模块，转换源码为浏览器可执行代码，并构建输出bundle。

具体工作流程步骤如下：

1. 初始化参数：取配置文件和shell脚本参数并合并
2. 开始编译：用上一步得到的参数初始化`compiler`对象，执行`run`方法开始编译
3. 确定入口：根据配置中的`entry`，确定入口文件
4. 编译模块：从入口文件出发，递归遍历找出所有依赖模块的文件
5. 完成模块编译：使用`loader`转译所有模块，得到转译后的最终内容和依赖关系
6. 输出资源：根据入口和模块依赖关系，组装成一个个`chunk`，加到输出列表
7. 输出完成：根据配置中的`output`，确定输出路径和文件名，把文件内容写入输出目录（默认是`dist`）

### Webpack实践

#### 1. 基础配置

**entry**

> 入口配置，webpack 编译构建时能找到编译的入口文件，进而构建内部依赖图。

**output**

> 输出配置，告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。

**loader**

> 模块转换器，loader 可以处理浏览器无法直接运行的文件模块，转换为有效模块。比如：css-loader和style-loader处理样式；url-loader和file-loader处理图片。

**plugin**

> 插件，解决 loader 无法实现的问题，在 webpack 整个构建生命周期都可以扩展插件。比如：打包优化，资源管理，注入环境变量等。

下面是 webpack 基本配置的简单示例：

```js
const path = require("path");

module.exports = {
  mode: "development",
  entry: "./src/index.js",
  output: {
    filename: "main.js",
    path: path.resolve(__dirname, "dist"),
  },
  devServer: {
    static: "./dist",
  },
  module: {
    rules: [
      {
        // 匹配什么样子的文件
        test: /\.css$/i,
        // 使用loader ， 从后到前执行
        use: ["style-loader", "css-loader"],
      }
    ],
  },
};
```



## Rollup

### Rollup概述

**Rollup** 是一个 **JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码**，例如 library 或应用程序。并且可以对代码模块使用新的标准化格式，比如`CommonJS` 和 `es module`。

### Rollup原理

我们先来了解下 `Rollup` 原理，其主要工作机制是：

1. 确定入口文件
2. 使用 `Acorn` 读取解析文件，获取抽象语法树 AST
3. 分析代码
4. 生成代码，输出

`Rollup` 相对 `Webpack` 而言，打包出来的包会更加轻量化，更适用于类库打包，因为内置了 Tree Shaking 机制，在分析代码阶段就知晓哪些文件引入并未调用，打包时就会自动擦除未使用的代码。

Acorn 是一个 JavaScript 语法解析器，它将 JavaScript 字符串解析成语法抽象树 AST 如果想了解 AST 语法树可以点下这个网址**astexplorer.net/**

### Rollup实践

**input**

> 入口文件路径

**output**

> 输出文件、输出格式（amd/es6/iife/umd/cjs）、sourcemap启用等。

**plugin**

> 各种插件使用的配置

**external**

> 提取外部依赖

**global**

> 配置全局变量



下面是 Rollup 基础配置的简单示例：

```js
import commonjs from "@rollup/plugin-commonjs";
import resolve from "@rollup/plugin-node-resolve";
// 解析json
import json from '@rollup/plugin-json'
// 压缩代码
import { terser } from 'rollup-plugin-terser';
export default {
  input: "src/main.js",
  output: [{
    file: "dist/esmbundle.js",
    format: "esm",
    plugins: [terser()]
  },{
    file: "dist/cjsbundle.js",
    format: "cjs",
  }],
  // commonjs 需要放到 transform 插件之前，
  // 但是又个例外， 是需要放到 babel 之后的
  plugins: [json(), resolve(), commonjs()],
  external: ["vue"]
};
```



## Vite

### Vite概述

**Vite**，相比 Webpack、Rollup 等工具，极大地改善了前端开发者的开发体验，编译速度极快。

### Vite原理

Vite 原理是利用**现代主流浏览器支持原生的 ESM 规范，配合 server 做拦截，把代码编译成浏览器支持的**



## 3种构建工具综合对比

|              |   Webpack    |      Rollup      |        Vite        |
| :----------: | :----------: | :--------------: | :----------------: |
|   编译速度   |     一般     |       较快       |        最快        |
|  HMR热更新   |     支持     | 需要额外引入插件 |        支持        |
| Tree Shaking | 需要额外配置 |       支持       |        支持        |
|   适用范围   |   项目打包   |     类库打包     | 不考虑兼容性的项目 |
